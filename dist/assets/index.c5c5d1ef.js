var te=Object.defineProperty;var ie=(l,e,t)=>e in l?te(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var c=(l,e,t)=>(ie(l,typeof e!="symbol"?e+"":e,t),t),ne=(l,e,t)=>{if(!e.has(l))throw TypeError("Cannot "+t)};var V=(l,e,t)=>(ne(l,e,"read from private field"),t?t.call(l):e.get(l)),$=(l,e,t)=>{if(e.has(l))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(l):e.set(l,t)};import{H as se,M as oe,V as b,S as z,D as K,P as L,T as U,C as q,a as w,b as ae,A as M,B as H,c as le,R as re,d as G,e as E,W as he,E as ce,f as de,U as me,g as ge,h as fe}from"./vendor.f9fe2758.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const i of n)if(i.type==="childList")for(const r of i.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function t(n){const i={};return n.integrity&&(i.integrity=n.integrity),n.referrerpolicy&&(i.referrerPolicy=n.referrerpolicy),n.crossorigin==="use-credentials"?i.credentials="include":n.crossorigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(n){if(n.ep)return;n.ep=!0;const i=t(n);fetch(n.href,i)}})();window.exports=window;class ue{constructor(e,t,s,n=0){c(this,"complete",!1);c(this,"title");c(this,"description");c(this,"failed",!1);c(this,"onFail");c(this,"onSuccess");c(this,"onCompletion");c(this,"currentState");c(this,"tasks");c(this,"resetSOP",()=>{this.currentState=0,this.failed=!1,this.complete=!1});this.title=e,this.description=t,this.tasks=s,this.currentState=n}}const v=60,pe=50,Y=3,x="cylinder",F="liquid",ye="placard",f=new ue("","",[{next:"CtoA",label:"BtoC"},{next:"complete",label:"CtoA"}]);function C(l,e){return l.getChildMeshes().find(t=>t.name===e)||null}function T(l){l.rotation.x=0,l.rotation.y=0,l.rotation.z=0}function j(l){l.position.x=0,l.position.y=0,l.position.z=0}class _{constructor(e,t,s,n){c(this,"name");c(this,"position");c(this,"mesh");c(this,"dragCollision");c(this,"highlightLayer");c(this,"scene");c(this,"particleSystem");console.log(e),this.name=s;const i=e.getScene();this.scene=i,this.highlightLayer=new se("highlight-layer",i),this.highlightLayer.innerGlow=!0,this.highlightLayer.outerGlow=!1;const r=i.getMeshByName("Table");let a=oe.CreateSphere(`pivot-Cylinder-${s}`,{segments:2,diameterX:.15,diameterY:.33,diameterZ:.2},e.getScene());if(a.visibility=0,e.name=s,e.parent=a,e.rotationQuaternion=null,e.getChildMeshes().forEach(p=>{switch(p.name){case"BeakerwOpacity":p.name=x,p.rotationQuaternion=null,p.rotation.z=2*Math.PI,p.isPickable=!1;break;case"BeakerLiquid":p.name=F,p.isPickable=!1;break}}),r){const p=r.getBoundingInfo().boundingBox,N=C(e,x).getBoundingInfo().boundingBox.maximum.y+1e-8;a.position.y=p.maximumWorld.y+N,a.position.x=(p.maximumWorld.x-p.minimumWorld.x)/Y*t+p.minimumWorld.x-.3,a.position.z=(p.centerWorld.z+p.minimumWorld.z)/2,this.position={...a.position}}else a.position.x=-2+t,a.position.y=1.22,a.position.z=.5;a.checkCollisions=!0,a.ellipsoid=new b(.02,.16,.02),this.mesh=a;const d=C(e,F),m=new z("liquid-material");m.diffuseColor=n,d.material=m;const g=C(e,"Label"),h=C(e,"LabelBack");console.log("Label:",h);const o=new K("dynamic texture",256,i),A=new z("Mat",i);A.diffuseTexture=o,g.material=A,h.material=A;const P="bold 300px monospace";o.drawText(e.name.toUpperCase(),65,225,P,"black","white");let B=this.mesh.getChildMeshes().find(p=>p.name==="cylinder");this.mesh.animations=B.animations,console.log("Children: ",this.mesh.getChildMeshes());const u=new L("particles",500,this.scene);u.particleTexture=new U("https://raw.githubusercontent.com/PatrickRyanMS/BabylonJStextures/master/FFV/smokeParticleTexture.png",this.scene),u.minLifeTime=.5,u.maxLifeTime=.7,u.emitRate=100,u.gravity=new b(0,.5,0),u.minSize=.01,u.maxSize=.07,u.createPointEmitter(new b(0,0,0),new b(0,1,0)),u.addColorGradient(1,q.FromColor3(d.material.diffuseColor,1)),u.blendMode=L.BLENDMODE_STANDARD,u.emitter=this.mesh.position,this.particleSystem=u,this.addDragCollision()}startParticles(){this.particleSystem.start()}highlight(e=!0){let t=C(this.mesh,x);e?(console.log("Adding mesh"),this.highlightLayer.hasMesh(t)||this.highlightLayer.addMesh(t,w.Green())):this.highlightLayer.hasMesh(t)&&this.highlightLayer.removeMesh(t)}addDragCollision(){let e=new ae({dragPlaneNormal:new b(0,0,1)});e.useObjectOrientationForDragging=!1,e.moveAttached=!1,e.onDragStartObservable.add(()=>{}),e.onDragObservable.add(t=>{this.mesh.moveWithCollisions(t.delta)}),e.onDragEndObservable.add(()=>{this.fadeAndRespawn()}),this.mesh.addBehavior(e),this.dragCollision=e}removeDragCollision(){this.mesh.removeBehavior(this.dragCollision)}fadeAndRespawn(e=pe){setTimeout(()=>{this.mesh.isPickable=!1;let t=60;this.mesh.name.split("-")[0];let s=this.mesh.getScene(),n=this.mesh.getChildMeshes(),i=n.find(a=>a.name==="cylinder");n.find(a=>a.name==="liquid");let r=[{name:"Invisibility",startValue:1},{name:"Visibility",startValue:0}];r.forEach(a=>{a.init=new M(a.name,"visibility",120,M.ANIMATIONTYPE_FLOAT,M.ANIMATIONLOOPMODE_CONSTANT),a.init.setKeys([{frame:0,value:a.startValue},{frame:t,value:1-a.startValue}])});for(let a=0;a<n.length-1;++a){let d=n[a];s.beginDirectAnimation(d,[r[0].init],0,60,!1)}s.beginDirectAnimation(n[n.length-1],[r[0].init],0,60,!1,void 0,()=>{console.log(this.mesh,this.position),this.mesh.position.x=this.position._x,this.mesh.position.y=this.position._y,this.mesh.position.z=this.position._z,this.mesh.animations=i.animations;let a=C(this.mesh,x);T(this.mesh),T(a),j(a);for(let d=0;d<n.length-1;++d){let m=n[d];s.beginDirectAnimation(m,[r[1].init],0,60,!1)}s.beginDirectAnimation(n[n.length-1],[r[1].init],0,60,!1,void 0,()=>{this.highlight(!1),this.mesh.isPickable=!0})})},e)}rotateAroundZ(){let e=this.mesh.getAnimationByName(`${this.name}-rotateAroundZ`);this.scene.beginDirectAnimation(C(this.mesh,x),[e],0,60,!1,void 0,()=>{})}resetAroundZ(){let e=this.mesh.getAnimationByName(`${this.name}-resetRotateAroundZ`);this.scene.beginDirectAnimation(C(this.mesh,x),[e],0,60,!1,void 0,()=>{})}}function be(l){l.name="clipboard";const e=l.getScene(),t=e.getMeshByName("Table");if(t){const n=t.getBoundingInfo().boundingBox;l.position.y=n.maximumWorld.y+.003}l.rotationQuaternion=null,l.rotation=new b(0,Math.PI/4,0);const s=e.getMeshByName("pivot-Cylinder-A");s&&(l.position.x=s.position.x+.2,l.position.z=s.position.z+.5)}function Me(l){var e=new H(w.FromHexString("#0984e3"));e.ignoreChildren=!0;var t=l[0],s=H.MakeNotPickableAndWrapInBoundingBox(t);e.attachedMesh=s,e.onScaleBoxDragObservable.add(()=>{console.log("scaleDrag")}),e.onScaleBoxDragEndObservable.add(()=>{const n=e.attachedMesh;if(n){const i=n.getHierarchyBoundingVectors(!0);console.log("size x:",i.max.x-i.min.x),console.log("size y:",i.max.y-i.min.y),console.log("size z:",i.max.z-i.min.z)}console.log("scaleEnd")}),e.onRotationSphereDragObservable.add(()=>{console.log("rotDrag")}),e.onRotationSphereDragEndObservable.add(()=>{console.log("rotEnd")})}function R(l,e,t){const s=l.find(h=>h.name==="__root__"),n=s.getScene();s.name=t;const i=l.find(h=>h.name==="Label"),r=l.find(h=>h.name==="Placard");r.name=ye;const a=new K("dynamic texture",256,n);a.wAng=-Math.PI/2,a.uAng=Math.PI;const d=new z("Mat",n);d.diffuseTexture=a,i.material=d;const m="bold 220px monospace";a.drawText(s.name.split("-")[1].toUpperCase(),65,185,m,"black","white"),r.addChild(i),r.rotationQuaternion=null,r.rotation=new b(0,Math.PI/2,0);const g=n.getMeshByName("Table");if(g){const h=g.getBoundingInfo().boundingBox;s.position.y=h.maximumWorld.y+.003,s.position.x=(h.maximumWorld.x-h.minimumWorld.x)/Y*e+h.minimumWorld.x-.2,s.position.z=(h.centerWorld.z+h.minimumWorld.z)/2+.2}}function Ce(l,e,t){let s;return new Promise(n=>{const i="./models/";let r="";var a={};let d=["left","right"];const m=new le(l);d.forEach(h=>{m.addMeshTask(`load ${h} hand`,"",i,`${h}${r}.glb`)});let g=0;m.onTaskSuccess=h=>{a[d[g]]=h.loadedMeshes[1],h.loadedMeshes[1].name=d[g],s=h.loadedAnimationGroups;for(let o=0;o<s.length;o++)s[o].name=`${d[g]}_${s[o].name}`;g++},m.onTasksDoneObservable.add(()=>{for(let h=0;h<l.animationGroups.length;h++)l.animationGroups[h].pause();e.input.onControllerAddedObservable.add(h=>{let o=h.inputSource.handedness;console.log(a[o]);let A=a[o].parent.parent;a[o].isPickable=!1;for(let O of t)O.removeDragCollision();let P=(Object.keys(a).indexOf(o)-1)*2-1;a[o].rotation.y=Math.PI*P,a[o].rotation.z=0,a[o].rotation.x=-Math.PI/4,A.parent=h.grip||h.pointer})}),m.loadAsync().then(()=>{n(s)})})}class X{constructor(e,t){c(this,"cylinderInstances");c(this,"clipboard");c(this,"scene");c(this,"labels");this.labels=["A","B","C"],this.scene=e,this.cylinderInstances=t}getCylinderInstanceFromMesh(e){let t=e.name.split("-")[2];console.log("Name: ",t);for(let s of this.cylinderInstances)if(console.log("Instance name: ",s.name),s.name==t)return s;return null}intersectHandCylinder(e){for(let t of this.labels){let s=this.scene.getMeshByName(`pivot-Cylinder-${t}`);if(e.intersectsMesh(s,!1))return s}return null}intersectCylinder(e){for(let t of this.labels){let s=this.scene.getMeshByName(`pivot-Cylinder-${t}`);if(s!=e&&e.intersectsMesh(s))return s}return null}highlightAndRotateCylinders(e,t,s){e.highlight(),t.highlight();let n=e.mesh.getAbsolutePosition()._x,i=t.mesh.getAbsolutePosition()._x;if(i<n?(console.log("Left hit!"),e.mesh.rotation.y=Math.PI,t.mesh.rotation.y=e.mesh.rotation.y):(console.log("Right hit!"),e.mesh.rotation.y=0,t.mesh.rotation.y=e.mesh.rotation.y),!s){s=!0;let r=e.mesh.getHierarchyBoundingVectors(),a=r.max.y-r.min.y,d=-.09,g=n-i,h=C(e.mesh,x);i<n?(console.log("Src pos: ",e.position.x),h.position.x=g+d,h.position.y=a-.2):(h.position.x=g-d,h.position.y=a-.2),e.rotateAroundZ()}return s}moveWithCollisions(e,t){e.moveWithCollisions(t)}}class Q extends X{constructor(e,t){super(e,t)}resetCylinders(){console.log(this);let e=["A","B","C"];for(let t=0;t<e.length;t++){const s=this.scene.getMeshByName(`pivot-Cylinder-${e[t]}`),n=this.scene.getMeshByName("Table");if(n&&s){const i=n.getBoundingInfo().boundingBox;s.position.z=(i.centerWorld.z+i.minimumWorld.z)/2}}}postSceneCylinder(){this.resetCylinders();let e=["A","B","C"],t=[];for(let n of e){const i=this.scene.getMeshByName(`pivot-Cylinder-${n}`);t.push(i);let r=new M(`${n}-rotateAroundZ`,"rotation.z",120,M.ANIMATIONTYPE_FLOAT,M.ANIMATIONLOOPMODE_CONSTANT),a=C(i,x);const d=[];d.push({frame:0,value:Math.PI*2}),d.push({frame:60,value:4.62}),a.animations.push(r),r.setKeys(d);let m=new M(`${n}-resetRotateAroundZ`,"rotation.z",120,M.ANIMATIONTYPE_FLOAT,M.ANIMATIONLOOPMODE_CONSTANT);const g=[];g.push({frame:0,value:4.62}),g.push({frame:60,value:Math.PI*2}),a.animations.push(m),m.setKeys(g)}let s=!1;for(let n=0;n<e.length;n++){const i=this.scene.getMeshByName(`pivot-Cylinder-${e[n]}`);let r=super.getCylinderInstanceFromMesh(i);console.log("Dragging!");const a=i.getBehaviorByName("PointerDrag");console.log(a);let d=[];for(let h of t)h!=i&&d.push(h);let m=C(i,x),g=!1;a.onDragObservable.add(()=>{let h=!1;T(i);const o=super.intersectCylinder(i);if(o){let A=super.getCylinderInstanceFromMesh(o);console.log("Hit!"),h=!0;let P=o.name.split("-")[2],B=`${i.name.split("-")[2]}to${P}`;if(f.tasks[f.currentState].label===B)f.tasks[f.currentState].next==="complete"?(this.resetCylinders(),r.fadeAndRespawn(),f.resetSOP()):f.currentState=f.tasks.indexOf(f.tasks.find(y=>y.label==f.tasks[f.currentState].next));else if(!s){s=!0;const y=new L("particles",500,this.scene);y.particleTexture=new U("https://raw.githubusercontent.com/PatrickRyanMS/BabylonJStextures/master/FFV/smokeParticleTexture.png",this.scene),y.minLifeTime=.5,y.maxLifeTime=.7,y.emitRate=100,y.gravity=new b(0,.5,0),y.minSize=.01,y.maxSize=.07,y.createPointEmitter(new b(0,0,0),new b(0,1,0));const I=C(o,F);y.addColorGradient(1,q.FromColor3(I.material.diffuseColor,1)),y.blendMode=L.BLENDMODE_STANDARD,y.emitter=o.position,y.start()}let u=i.getAbsolutePosition()._x;o.getAbsolutePosition()._x<u?(m.rotation.y=Math.PI,o.rotation.y=m.rotation.y):(m.rotation.y=0,o.rotation.y=m.rotation.y),g||(g=super.highlightAndRotateCylinders(r,A,g))}else r.highlight(!1),T(i);h==!1&&(r.highlight(!1),g&&(m.position.x=0,m.position.y=0,g=!1,r.resetAroundZ()))}),a.onDragEndObservable.add(()=>{C(i,x).getBehaviorByName("Highlight");for(let h of d)h!=m&&(r.highlight(!1),super.getCylinderInstanceFromMesh(h).highlight(!1),m.intersectsMesh(h)&&(r.resetAroundZ(),m.position.x=0,m.position.y=0,g=!1))})}}}class Z extends X{constructor(t,s,n){super(s,n);c(this,"handedness");c(this,"holdingInstance");c(this,"holdingMesh");c(this,"targetMesh");c(this,"targetMeshInstance");c(this,"motionController");c(this,"handMesh");c(this,"isVisible");c(this,"failBeaker");this.handedness=t,this.handMesh=s.getMeshByName(this.handedness),this.isVisible=!0,this.failBeaker=!1}getMotionController(){return this.motionController}setMotionController(t){this.motionController=t}dropped(t){this.motionController.lastPosition=null,clearInterval(t),this.motionController.grabbed=!1,this.motionController.meshGrabbed=void 0,console.log(this.holdingMesh),this.holdingMesh&&(this.holdingInstance.fadeAndRespawn(100),this.holdingMesh=null,this.holdingInstance=null,this.motionController.meshGrabbed=null,this.targetMesh=null,this.targetMeshInstance=null)}updateSOPTask(t,s,n){console.log(this.scene);let i=`${t}to${s}`;if(f.tasks[f.currentState].label===i){if(f.tasks[f.currentState].next==="complete"){let r=new Q(this.scene,super.cylinderInstances);for(let a of this.cylinderInstances)a.fadeAndRespawn(100);return this.disappearAnimation(!1),this.dropped(n),r.resetCylinders(),f.resetSOP(),!0}}else return console.log("Target mesh: ",this.targetMeshInstance),f.currentState=f.tasks.indexOf(f.tasks.find(r=>r.label==f.tasks[f.currentState].next)),!1}disappearAnimation(t=!0){console.log("DISAPPEAR: ",t);let s=30,n=[{name:"Invisibility",startValue:1},{name:"Visibility",startValue:0}];n.forEach(i=>{i.init=new M(i.name,"visibility",120,M.ANIMATIONTYPE_FLOAT,M.ANIMATIONLOOPMODE_CONSTANT),i.init.setKeys([{frame:0,value:i.startValue},{frame:s,value:1-i.startValue}])}),console.log(this.handMesh),t?(this.isVisible=!1,this.scene.beginDirectAnimation(this.handMesh,[n[0].init],0,s,!1)):(this.isVisible=!0,this.scene.beginDirectAnimation(this.handMesh,[n[1].init],0,s,!1))}}function Ae(l,e,t,s){let n=new Z("right",l,s),i=new Z("left",l,s),r=!1,a={right:n,left:i},d=!1;e.input.onControllerAddedObservable.add(m=>{m.onMotionControllerInitObservable.add(g=>{let h=g;h.handID=g.handedness;let o=a[h.handedness];o.getMotionController()||o.setMotionController(h),console.log(o);let A=new re(b.Zero(),b.Zero(),.25);const P=g.getComponentOfType("squeeze");g.getComponentOfType("trigger"),[P].forEach(O=>{console.log(l.getMeshByName("left")),O.onButtonStateChangedObservable.add(B=>{let u,p={left:"Fist",right:"Grip"},y=l.animationGroups.find((N,k)=>N.name===`${o.motionController.handID}_${p[o.motionController.handID]}`);y.goToFrame(B.value*(y._to-1)+1);let I=o.intersectHandCylinder(l.getMeshByName(h.handID));if(console.log("Grabbed Cylinder: ",I),B.value>0&&!o.motionController.grabbed){if(I){r=!1,o.holdingMesh=I,o.holdingInstance=o.getCylinderInstanceFromMesh(o.holdingMesh),o.motionController.meshGrabbed=o.holdingMesh,o.motionController.grabbed=!0;let N=o.motionController.lastPosition,k=A.origin;k!=N&&(o.disappearAnimation(!0),u=setInterval(()=>{let W=o.motionController.lastPosition;if(m.getWorldPointerRayToRef(A),W&&o.holdingMesh&&o.moveWithCollisions(o.holdingMesh,k.subtract(W)),!o.intersectHandCylinder(l.getMeshByName(o.motionController.handID))&&o.holdingMesh&&(o.targetMeshInstance&&o.targetMeshInstance.highlight(!1),o.dropped(u),o.motionController.grabbed=!1,o.handMesh.visibility=1,r=!0),o.holdingMesh){let S=o.intersectCylinder(o.holdingMesh);if(S){o.targetMesh=S,o.targetMeshInstance=o.getCylinderInstanceFromMesh(S);let J=S.name.split("-")[2],ee=o.holdingMesh.name.split("-")[2];d=o.highlightAndRotateCylinders(o.holdingInstance,o.targetMeshInstance,d),r=o.updateSOPTask(ee,J,u)}else o.targetMeshInstance&&(o.targetMeshInstance.highlight(!1),o.targetMesh=null),o.holdingInstance.highlight(!1),d&&(o.holdingInstance.resetAroundZ(),j(C(o.holdingMesh,x)),d=!1)}r||(o.motionController.lastPosition=Object.assign({},A.origin),h.lastPosition=Object.assign({},A.origin))},10))}}else(!B.value||!I)&&o.holdingMesh&&(o.holdingInstance.highlight(!1),o.motionController.grabbed=!1,o.targetMeshInstance&&o.targetMeshInstance.highlight(!1),o.targetMesh=null,o.dropped(u),o.disappearAnimation(!1))})})})})}var D;class xe{constructor(e){c(this,"flying",!1);c(this,"active",!1);c(this,"camera");c(this,"mesh");c(this,"offset",.3);c(this,"animations");c(this,"returnPosition");c(this,"returnRotation");c(this,"onPointerDownObserver");c(this,"xrCamera");c(this,"attach",(e,t,s,n,i)=>{const r=e.getScene();if(this.mesh=e,!t&&(t=r.activeCamera,!t))throw new Error("The scene has no active camera, and no camera was provided.");this.camera=t,s||(s=this.mesh.position),n||(n=this.mesh.rotation),i&&(this.offset=i),this.returnPosition=s,this.returnRotation=n,this.onPointerDownObserver=r.onPointerObservable.add(this.clipboardClick)});c(this,"detach",()=>{this.mesh.getScene().onPointerObservable.remove(this.onPointerDownObserver)});c(this,"clipboardClick",(e={type:G.POINTERDOWN,pickInfo:{pickedMesh:this.mesh}})=>{var t;if(e.type===G.POINTERDOWN){console.log("Clipboard click");const s=(t=e.pickInfo)==null?void 0:t.pickedMesh;if(s&&(s===this.mesh||s.isDescendantOf(this.mesh))&&!this.flying||this.active){const n=this.active?v/2:0,i=this.active?0:v/2;V(this,D).call(this),this.flying=!0,this.mesh.billboardMode==E.BILLBOARDMODE_ALL?this.mesh.billboardMode=E.BILLBOARDMODE_NONE:this.mesh.billboardMode=E.BILLBOARDMODE_ALL,this.mesh.getScene().beginDirectAnimation(this.mesh,this.animations,n,i,!1,void 0,()=>{this.flying=!1,this.active=!this.active})}}});c(this,"calculateTargetPositionWithOffset",e=>{if(this.xrCamera!==void 0&&this.xrCamera.state===he.IN_XR){const r=this.xrCamera.camera._position.subtract(this.returnPosition).scale(1-e/b.Distance(this.returnPosition,this.xrCamera.camera._position));return this.returnPosition.add(r)}const s=this.camera._position.subtract(this.returnPosition).scale(1-e/b.Distance(this.returnPosition,this.camera._position));return this.returnPosition.add(s)});c(this,"setClipboardUp",()=>new b(3.1468286,4.6617744,1.680752));$(this,D,()=>{const e=this.animations.find(({name:i})=>i==="translate"),t=this.animations.find(({name:i})=>i==="rotate"),s=[{frame:0,value:this.returnPosition},{frame:v/2,value:this.calculateTargetPositionWithOffset(this.offset)}],n=[{frame:0,value:this.returnRotation},{frame:v/2,value:this.setClipboardUp()}];e.setKeys(s),t.setKeys(n)});const t=new M("translate","position",v,M.ANIMATIONTYPE_VECTOR3),s=new M("rotate","rotation",v,M.ANIMATIONTYPE_VECTOR3);this.animations=[t,s],this.xrCamera=e}get name(){return"FlyToCamera"}init(){}}D=new WeakMap;console.log=()=>{};class Pe{constructor(){c(this,"handAnimation");c(this,"sop");c(this,"models");c(this,"cylinders");this.cylinders=[];let e="TLLGraduatedCylinderNewLabel.glb";this.models=[{fileName:"NewLaboratoryUNFINISHED.glb",callback:t=>this.createRoom(t),label:"floor"},{fileName:"clipBoardWithPaperCompressedTexture.glb",callback:t=>be(t[0])},{fileName:"Placard_Label.glb",callback:t=>R(t,1,"Placard-A")},{fileName:"Placard_Label.glb",callback:t=>R(t,2,"Placard-B")},{fileName:"Placard_Label.glb",callback:t=>R(t,3,"Placard-C")},{fileName:e,callback:t=>this.cylinders.push(new _(t[0],1,"A",new w(1,0,0))),label:"Cylinder-A"},{fileName:e,callback:t=>this.cylinders.push(new _(t[0],2,"B",new w(0,1,0))),label:"Cylinder-B"},{fileName:e,callback:t=>this.cylinders.push(new _(t[0],3,"C",new w(0,0,1))),label:"Cylinder-C"}].map(function(t){return Object.assign({},{fileName:"LabBench.glb",root:"./models/",callback:Me,label:"NoLabel"},t)}),this.createScene().then(t=>{for(let s of["A","B","C"])Object.assign({},t.getMeshByName(`pivot-Cylinder-${s}`).position);this.processScene(t,this.cylinders)})}async processScene(e,t){let s=e.getCameraByName("camera"),n=e.getLightByName("light1"),i;s.speed=.16;let r=setInterval(()=>{n.intensity>=1?clearInterval(r):n.intensity+=.1},60);const a=["WallsandFloor","WallsAndFloor.001"],d=[];for(let g of a){console.log(g);const h=e.getMeshByName(g);h&&d.push(h)}let m={floorMeshes:d,inputOptions:{doNotLoadControllerMeshes:!0}};i=await e.createDefaultXRExperienceAsync(m),i.pointerSelection.displayLaserPointer=!1,i.pointerSelection.displaySelectionMesh=!1,Ce(e,i,t).then(g=>{if(console.log("add webxr"),i){const o=new xe(i.baseExperience);e.getMeshByName("clipboard").addBehavior(o)}new Q(e,t).postSceneCylinder(),Ae(e,i,g,t)})}createRoom(e){const t=["WallsandFloor","WallsAndFloor.001","Table","Roof","Countertop","Walls"];let s,n;for(let i of t){const r=e.find(a=>a.name===i);if(r&&(r.checkCollisions=!0,r.name==="Table")){const d=r.getBoundingInfo().boundingBox.center.x;s=r.getScene(),n=s.getCameraByName("camera"),n.position.x=d-.7}}}createScene(){return new Promise(e=>{const t=document.getElementById("canvas"),s=new ce(t,!0,{stencil:!0}),n=new de(s);n.collisionsEnabled=!0,window.addEventListener("resize",function(){s.resize()});const i=new me("camera",new b(0,1.84,-1.134),n);i.ellipsoid=new b(.4,.7,.4),i.attachControl(t,!0),i.applyGravity=!0,i.minZ=0,i.speed=0,i.checkCollisions=!0,i.keysUp.push(87),i.keysDown.push(83),i.keysLeft.push(65),i.keysRight.push(68);var r=new ge("light1",new b(1,1,0),n);r.intensity=0,Promise.all(this.models.map(a=>new Promise(d=>fe.ImportMesh("",a.root,a.fileName,n,function(m){a.mesh=m,d(m)})))).then(()=>{let a=[];this.models.map(d=>{a.push(d.callback(d.mesh)),e(n)})}),window.addEventListener("keydown",a=>{a.shiftKey&&a.ctrlKey&&a.altKey&&a.keyCode===73&&(n.debugLayer.isVisible()?n.debugLayer.hide():n.debugLayer.show())}),s.runRenderLoop(()=>{n.render()})})}}new Pe;
